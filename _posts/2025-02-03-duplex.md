---
title: 실시간 양방향 통신 - polling, sse, websocket
date: 2025-02-03 00:00:00 +0900
categories: [Engineering, Infra]
tags: [Polling, SSE, WebSocket]
toc: true
comments: true
---

# 웹에서 실시간 통신은 왜 어려울까?

웹에서 “실시간”이라는 단어는 늘 까다로운 주제다.

그 이유는 웹의 근간이 되는 **HTTP 프로토콜의 구조적 한계** 때문이다.

HTTP는 기본적으로 **클라이언트가 요청을 보내야만 서버가 응답할 수 있는 단방향(Request–Response) 구조**를 가진다.

즉, 서버는 스스로 먼저 말을 걸 수 없다.

하지만 현실의 서비스에서는 다음과 같은 요구가 끊임없이 등장한다.

- 새로운 알림이 도착했을 때 바로 알려주고 싶고
- 채팅 메시지를 즉시 전달하고 싶고
- 서버 상태 변화를 실시간으로 반영하고 싶다

이 간극을 메우기 위해, 웹은 여러 가지 **우회적인 실시간 통신 기법**을 발전시켜 왔다.

## Polling – 가장 단순한 접근

가장 먼저 등장한 방식은 **Polling**이다.

Polling은 매우 직관적이다.

클라이언트가 일정 주기마다 서버에 요청을 보내고, 응답을 받는 일을 반복한다.

> “혹시 바뀐 거 있어요?”
> 
> 
> “없어요.”
> 
> “그럼 3초 뒤에 다시 물어볼게요.”
> 

이런 대화를 끊임없이 반복하는 구조다.

과거에는 AJAX나 보이지 않는 iframe을 활용해 Polling을 구현했고,

AJAX의 등장 이후에는 비동기 요청 덕분에 훨씬 자연스럽게 사용되었다.

짧은 반응성만 필요했던 시절에는

이 방식만으로도 “어느 정도 실시간”처럼 느껴지던 때가 있었다.

하지만 Polling의 한계는 명확하다.

- 서버에 전달할 데이터가 없어도 요청은 계속 발생
- 불필요한 트래픽과 서버 부하
- 실시간 **양방향 통신과는 거리가 멀다**

## Long Polling – 기다림을 길게 가져가다

Polling의 낭비를 줄이기 위해 등장한 방식이 **Long Polling**이다.

Long Polling에서는 클라이언트가 요청을 보내면,

서버가 즉시 응답하지 않고 **요청을 보류(hold)** 한다.

그리고 서버에 전달할 데이터가 생기는 순간, 그때 응답을 보낸다.

클라이언트는 응답을 받자마자 다시 요청을 보낸다.

이 방식의 핵심은 다음 두 가지다.

- 데이터가 생길 때까지 서버가 응답을 미룬다
- 응답을 받는 즉시 클라이언트가 재요청한다

Polling에 비해 쓸데없는 요청은 줄어들었지만,

여전히 다음과 같은 한계를 가진다.

- 완전한 실시간 양방향 통신은 아님
- 서버 이벤트 빈도가 높으면 Polling과 큰 차이가 없음
- 연결/해제 오버헤드는 여전히 존재
- 타임아웃 관리 등 운영 부담 발생

## SSE – 서버가 흘려보내는 이벤트 스트림

**SSE(Server-Sent Events)**는 HTML5 표준으로 정의된 기술이다.

기존 방식들과 가장 큰 차이점은

**HTTP 연결을 끊지 않고 계속 유지한다는 점**이다.

서버는 `Content-Type: text/event-stream`으로 응답을 보내고,

브라우저는 이를 인식해 연결을 종료하지 않는다.

그 결과 서버는 **이벤트를 스트림 형태로 지속적으로 전송**할 수 있다.

SSE는 구조적으로 다음과 같은 특징을 가진다.

- 서버 → 클라이언트 **단방향 통신**
- 알림, 뉴스 피드와 같은 사용 사례에 적합
- 브라우저 차원에서 **자동 재연결 지원**

다만, 서버에서 클라이언트로만 데이터를 보내는 구조이기 때문에

자유로운 양방향 메시지 교환에는 적합하지 않다.

## WebSocket – 웹에서의 진짜 실시간 통신

**WebSocket**은 웹에서의 실시간 통신을 위해 설계된 전용 프로토콜이다.

초기 연결은 HTTP로 시작하지만,

서버와의 handshake 과정에서 프로토콜을 **WebSocket으로 업그레이드**한다.

그 이후부터는 HTTP가 아닌,

가벼운 **WebSocket 프레임**을 사용해 통신한다.

이 구조 덕분에 WebSocket은 다음을 가능하게 한다.

- 클라이언트 ↔ 서버 **완전한 양방향 통신**
- 헤더 없는 가벼운 패킷
- 매우 낮은 지연 시간

하지만 장점만 있는 것은 아니다.

- 연결을 지속적으로 유지해야 함
- 서버가 상태를 가지게 됨
- 로드 밸런서, 방화벽 환경에서 추가 고려 필요
- HTTP와는 다른 스케일링 전략 요구

즉, 성능은 뛰어나지만 **운영 난이도가 높은 기술**이다.

## 코드로 보는 차이

### Polling

```jsx
setInterval(() => {fetch('/news');
},3000);
```

### SSE

```jsx
newEventSource('/stream')
  .onmessage =(e) => {console.log(e.data);
  };
```

### WebSocket

```jsx
const ws =newWebSocket('ws://');
ws.onmessage =(e) =>console.log(e.data);
ws.send('Hello');
```

## 왜 WebSocket이 더 빠를까?

Polling과 Long Polling은 모두 **HTTP 기반**이다.

요청을 보낼 때마다 연결 수립 비용과 무거운 HTTP 헤더가 반복된다.

HTTP/2로 오면서 많이 개선되었지만,

요청-응답 구조 자체의 비용은 여전히 남아 있다.

반면 WebSocket은

- 최초 1회 연결 수립
- 이후 연결을 유지
- 가벼운 프레임만 교환

이라는 구조를 가진다.

이 차이가 곧 **오버헤드의 차이**이고,

체감 성능의 차이로 이어진다.

## 정리하며

| 방식 | 방향 | 실시간성 | 대표 용도 |
| --- | --- | --- | --- |
| Polling | 단방향 | Low | 상태 확인 |
| Long Polling | 단방향 | Medium | 간단한 알림 |
| SSE | Server → Client | High | 알림, 뉴스피드 |
| WebSocket | 양방향 | Very High | 채팅, 게임, 협업 |

실시간 통신에는 정답이 없다.

**어떤 데이터를, 얼마나 자주, 어떤 방향으로 전달해야 하는지**에 따라

가장 적합한 기술이 달라질 뿐이다.

기술을 선택하기 전에,

“정말 양방향이 필요한가?”

“서버가 먼저 알려줘야 하는가?”

이 질문부터 던져보는 것이 중요하다.
