---
title: 대규모 트래픽 자리 예약 시스템 - 대기열
date: 2025-02-02 00:00:00 +0900
categories: [Architecture, Ticket]
tags: [Architecture, Ticket, load]
toc: true
comments: true
---
지난 글에서는 대규모 트래픽 상황에서 자리를 예매하는 시스템의 전체 아키텍처에 대해 살펴보았습니다.
 
이번 글에서는 그중에서도 대기열에 초점을 맞춰, 어떤 방식으로 설계하고 구현할 수 있는지에 대해 이야기해 보려 합니다.

### 전체 아키텍처

![1](/assets/img/ticket-2/1.png)

## 대기열을 어떻게 구현할까요?

대기열을 구현하기 전에,

**먼저 어떤 대기열이 필요한지 요구사항을 명확히 정의할 필요가 있습니다.**

대기열은 구현 방식에 따라

- 제공할 수 있는 사용자 경험이 달라지고
- 시스템 복잡도와 운영 비용 역시 크게 달라지기 때문입니다.

대기열 설계를 위해, 최소한 다음 질문들에 답해야 합니다.

### 1. 들어온 순서대로 입장시켜야 하나요?

가장 기본적인 요구사항입니다.

“먼저 들어온 사용자가 먼저 입장한다”는 규칙이

**반드시 보장되어야 하는지**를 먼저 판단해야 합니다.

이 요구사항을 만족시키기 위한 구현 방식으로는

크게 다음 두 가지를 고려할 수 있습니다.

- **Cache 기반 방식** (예: Redis)
- **MQ 기반 방식** (예: Kafka)

어떤 방식을 선택하느냐에 따라

대기열의 성격, 확장 방식, 그리고 이후에 제공할 수 있는 기능이 달라집니다.

### 2. 내 순번과 내 앞 사람 수를 정확히 보여줘야 하나요?

이 요구사항은 단순한 기능 문제가 아니라

**사용자 경험(UX)** 과 직접적으로 연결됩니다.

사용자에게

- “현재 내 순번은 몇 번인지”
- “내 앞에 몇 명이 대기 중인지”

를 **정확하게 보여줘야 한다면**,

시스템은 사용자의 대기 상태에 대해 **즉각적인 피드백을 제공할 수 있어야 합니다.**

즉, 단순히 “대기 중입니다”라는 상태만 반환하는 것이 아니라,

**현재 위치를 실시간으로 조회할 수 있는 구조**가 필요합니다.

이 요구사항은 대기열 구현 방식 선택에 있어

꽤 강한 제약 조건으로 작용합니다.

### 3. 재접속이나 새로고침 시에도 같은 순번을 유지해야 하나요?

이 요구사항은 대기열을

- **일회성 이벤트**로 볼 것인지,
- 아니면 **사용자 상태(state)를 지속적으로 관리해야 하는 시스템**으로 볼 것인지를 결정합니다.
- 새로고침이나 네트워크 끊김 이후에도 같은 순번을 유지해야 한다면
    
    → 사용자 식별자, 세션, 토큰 등을 기반으로 **대기 상태를 유지**해야 합니다.
    
- 반대로 연결이 끊기면 다시 대기열에 진입해도 된다면
    
    → 상태 관리에 대한 부담은 크게 줄어듭니다.
    

## 요구사항 선택

이번 설계에서 제가 선택한 요구사항은 다음과 같습니다.

1. **들어온 순서대로 입장**
2. **내 순번과 앞에 남은 대기 인원 수를 사용자에게 제공**
3. **새로고침이나 재접속 시에도 기존 순번 유지**

이 요구사항들을 종합적으로 고려했을 때,

저는 **Cache 기반 방식**, 그중에서도

**Redis를 활용한 대기열 구현이 가장 적합하다**고 판단했습니다.

## 왜 Redis인가?

핵심은 한 가지입니다.

**“보여줘야 하기 때문입니다.”**

대기열 시스템에서는 단순히 선착순으로 처리하는 것뿐만 아니라,

**사용자에게 자신의 대기 상태를 지속적으로 피드백해주는 UX**가 매우 중요합니다.

즉,

- 선착순 처리 자체도 중요하지만
- “내가 지금 어디쯤 와 있는지”를 **계속 보여줄 수 있어야** 합니다.

이 지점에서 **MQ 방식과 Redis 방식은 본질적인 차이**를 보입니다.

### MQ는 순번 확인이 어렵다

MQ는 본질적으로 **메시지를 파이프라인처럼 흘려보내는 구조**입니다.

메시지는 앞에서부터 순차적으로 컨슈머에 의해 소비됩니다.

이 구조의 특징은 다음과 같습니다.

- 큐의 **중간 상태를 임의로 조회하기 어렵고**
- “현재 내가 몇 번째인지”를 즉시 알기 힘듭니다.

MQ는 흔히 **터널**에 비유됩니다.

터널 안에 들어간 차량이 지금 몇 번째인지 바로 확인하기 어려운 것과 비슷합니다.

Kafka의 경우 메시지를 로그 형태로 보관하긴 하지만,

여기서 중요한 개념은 “**어디까지 읽었는가(offset)**”이지,

**특정 사용자가 전체 큐에서 몇 번째에 위치해 있는지**를 즉시 조회하는 기능은 아닙니다.

즉, MQ는

**대기열의 상태를 사용자에게 보여주는 서비스**에 적합한 구조는 아닙니다.

### Redis ZSET은 ‘큐’라기보다 ‘랭킹 명단’에 가깝다

반면 Redis의 **Sorted Set(ZSET)** 은

단순한 큐라기보다는 **랭킹 명단에 가까운 자료구조**입니다.

대기열 자체가 하나의 데이터 구조로 유지되며,

**특정 사용자가 현재 몇 번째 위치에 있는지 즉시 확인**할 수 있습니다.

대표적인 명령은 다음과 같습니다.

- 현재 내 순번 조회
    
    → `ZRANK queue user`
    
- 전체 대기 인원 수
    
    → `ZCARD queue`
    
- 재접속 시 순번 유지
    
    → 멤버(UserId)가 남아 있으면 기존 순번 유지
    
- 대기 취소 / 만료 처리
    
    → `ZREM queue user`
    
- 트래픽 조절 (앞에서부터 N명 입장 허용)
    
    → `ZPOPMIN queue 1000`
    

이 구조의 가장 큰 장점은,

사용자가 새로고침이나 재접속을 하더라도

**다시 맨 뒤로 줄을 서는 것이 아니라, 기존 줄 자체가 서버에 남아 있다는 점**입니다.

대기열에서는 결국 **상태 관리(state management)** 가 핵심인데,

ZSET은 이 문제를 매우 단순하고 직관적으로 해결해줍니다.

### 중복 클릭(연타 문제)

![2](/assets/img/ticket-2/2.png)

대기열 시스템에서 흔히 발생하는 문제 중 하나는

사용자가 조급한 마음에 **클릭을 연타하거나 새로고침을 반복하는 경우**입니다.

MQ 방식에서는 이러한 요청이 그대로 들어오면

**중복 메시지가 큐에 쌓이게 됩니다.**

결국 MQ를 사용할 경우,

컨슈머 단계에서 별도의 **중복 제거 로직**을 반드시 구현해야 합니다.

반면 Redis ZSET에서는

**멤버를 사용자 식별값(UserId)** 으로 사용합니다.

- 동일한 멤버에 대해 같은 스코어로 `ZADD`를 수행하면
- 해당 멤버는 하나로 유지됩니다.

즉, 동일 사용자의 요청이 여러 번 들어와도

대기열 상태는 변하지 않습니다.

이러한 성질을 **멱등성(Idempotency)** 이라고 합니다.

> **멱등성**
> 
> 
> 같은 요청을 여러 번 수행해도 결과가 변하지 않는 성질
> 

ZSET의 `ZADD` 연산은

동일한 멤버에 대해 동일한 스코어를 사용한다면 **멱등적**입니다.

대기열에서 멱등성이 보장되면

시스템은 중복 요청에 훨씬 강해지고,

전체 트래픽 안정성도 크게 향상됩니다.

### 중간 이탈(취소 / 삭제)

대기 중인 사용자가 기다리다 지쳐 **취소**하는 경우도 반드시 고려해야 합니다.

MQ는 기본적으로 **앞에서부터 순차 소비**하는 구조이기 때문에,

큐 중간에 있는 특정 사용자만을 **즉시 제거하기가 어렵습니다.**

이를 해결하려면 보통

- 별도의 취소 목록 저장소를 두거나
- 컨슈머 단계에서 취소 여부를 검사해 필터링하는

추가적인 로직이 필요합니다.

반면 Redis ZSET에서는 다음 한 줄이면 충분합니다.

`ZREM waiting_queue user_b` 이 명령으로

**대기열 중간에 있는 사용자도 즉시 제거**할 수 있습니다.

## 아키텍처를 다시 그려보면 이렇습니다.

![3](/assets/img/ticket-2/3.png)

## 대기열에 등록된 사용자 순번은 어떻게 전달할까요?

대기 순번을 사용자에게 전달하는 방식으로는 보통 다음 세 가지를 고려합니다.

### 1. Polling

- 일정 주기마다 클라이언트가 서버에 순번을 요청
- 구현이 단순하고, **로드밸런서·프록시·보안 장비 환경에서 안정적**
- 실무에서 가장 널리 사용되는 방식

### 2. SSE (Server-Sent Events)

- 서버 → 클라이언트 **단방향 스트림**
- 실시간성은 확보되지만, 연결 관리와 재시도 로직이 필요
- 구현·운영 난이도는 중간 수준

### 3. WebSocket

- 서버 ↔ 클라이언트 **양방향 통신**
- 실시간 알림에 가장 적합
- 일부 환경에서는 **LB, 프록시, 보안 장비**에 의해 연결이 끊길 수 있음

## 그럼 우리는 어떤 방식을 선택하는 것이 좋을까요?

실시간성이 반드시 필요한 상황이 아니라면,

**WebSocket이 항상 최적의 선택은 아닙니다.**

대기열과 같은 기능에서는

밀리초 단위의 즉각적인 변화보다

**현재 상태를 안정적으로 확인할 수 있는 경험**이 더 중요하기 때문입니다.

SSE 방식은 연결이 끊어질 경우 재연결이 동시에 발생해

서버에 순간적인 부하가 몰릴 수 있으며,

연결을 유지하는 비용도 상대적으로 큽니다.

그래서 부하가 큰 환경에서는 **Polling 방식**을 선택하고,

상황에 따라 주기를 조절하는 **Adaptive Polling**을 함께 사용합니다.

- **가변 주기**: 서버가 응답 헤더로 다음 요청 시점을 지정
- **지터(Jitter)**: 요청 시점을 랜덤하게 분산

Polling은 HTTP 기반으로 동작해 인프라 환경에 안정적이며,

Redis와 함께 사용하면 대기 순번 조회도 빠르게 처리할 수 있습니다.

> 다만, 게임 서버처럼 **입장 순서를 밀리초 단위로 전달해야 하는 경우**라면
> 
> 
> WebSocket이 더 적합한 선택이 될 수 있습니다.
> 

## 정리

| 구분 | MQ (Kafka / RabbitMQ) | Redis (Sorted Set) |
| --- | --- | --- |
| **주 목적** | 비동기 처리, 버퍼링 | 실시간 랭킹, 상태 관리 |
| **순번 조회** | 어려움 | 가능 (O(log N)) |
| **중복 방지** | 별도 로직 필요 | Key 기반으로 자동 해결 |
| **임의 취소** | 중간 삭제 어려움 | `ZREM`으로 즉시 가능 |
